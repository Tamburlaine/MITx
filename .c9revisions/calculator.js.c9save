{"ts":1371050637969,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1371050649246,"patch":[[{"diffs":[[1,"var calculator = (function() {\r\n    exports = {};\r\n\r\n    var built_in_functions = {\r\n        abs: Math.abs,\r\n        acos: Math.acos,\r\n        asin: Math.asin,\r\n        atan: Math.atan,\r\n        atan2: Math.atan2, // 2 arg\r\n        ceil: Math.ceil,\r\n        cos: Math.cos,\r\n        exp: Math.exp,\r\n        floor: Math.floor,\r\n        log: Math.log,\r\n        max: Math.max, // multi-arg\r\n        min: Math.min, // multi-arg\r\n        pow: Math.pow, // 2 arg\r\n        round: Math.round,\r\n        sin: Math.sin,\r\n        sqrt: Math.sqrt,\r\n    };\r\n\r\n    var built_in_environment = {\r\n        pi: Math.PI,\r\n        e: Math.E,\r\n    };\r\n    \r\n    function new_environment() {\r\n        var env = {};\r\n        for (var v in built_in_environment) {\r\n            env[v] = built_in_environment[v];\r\n        }\r\n        return env;\r\n    }\r\n    exports.new_environment = new_environment;\r\n\r\n// if first token is t, consume it and return true\r\n    function read_token(t, tokens) {\r\n        if (tokens.length > 0 && tokens[0] == t) {\r\n            tokens.shift();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // builds parse tree for following BNF.  Tree is either a number or\r\n    // or an array of the form [operator,tree,tree].\r\n    // <expression> ::= <term> | <expression> \"+\" <term> | <expression> \"-\" <term>\r\n    // <term>       ::= <unary> | <term> \"*\" <unary> | <term> \"/\" <unary>\r\n    // <unary>      ::= <factor> | \"-\" <factor> | \"+\" <factor>\r\n    // <factor>     ::= <number> | \"(\" <expression> \")\"\r\n    function parse_expression(tokens) {\r\n        var expression = parse_term(tokens);\r\n        while (true) {\r\n            if (read_token('+', tokens)) {\r\n                expression = ['+', expression, parse_term(tokens)];\r\n            }\r\n            else if (read_token('-', tokens)) {\r\n                expression = ['-', expression, parse_term(tokens)];\r\n            }\r\n            else break;\r\n        }\r\n        return expression;\r\n    }\r\n\r\n    function parse_term(tokens) {\r\n        var term = parse_exp(tokens);\r\n        while (true) {\r\n            if (read_token('*', tokens)) {\r\n                term = ['*', term, parse_exp(tokens)];\r\n            }\r\n            else if (read_token('/', tokens)) {\r\n                term = ['/', term, parse_exp(tokens)];\r\n            }\r\n            else break;\r\n        }\r\n        return term;\r\n    }\r\n\r\n    function parse_exp(tokens) {\r\n        var term = parse_unary(tokens);\r\n        while (true) {\r\n            if (read_token('^', tokens)) {\r\n                term = ['^', term, parse_unary(tokens)];\r\n            }\r\n            else break;\r\n        }\r\n        return term;\r\n    }\r\n\r\nfunction parse_unary(tokens) {\r\n        if (read_token('-', tokens)) {\r\n            return ['neg', parse_factor(tokens)];\r\n        }\r\n        else if (read_token('+', tokens)) {}\r\n        return parse_factor(tokens);\r\n    }\r\n\r\n\r\n    function parse_factor(tokens) {\r\n        if (read_token('(', tokens)) {\r\n            var exp = parse_expression(tokens);\r\n            if (read_token(')', tokens)) {\r\n                return exp;\r\n            }\r\n            else throw 'Missing ) in expression';\r\n        }\r\n        else if (tokens.length > 0) {\r\n            var token = tokens.shift();\r\n            if (token.search(/[a-zA-Z_]\\w*/) != -1) {\r\n                // variable name\r\n                if (read_token('(', tokens)) {\r\n                    // a function call, parse the argument(s)\r\n                    var args = [];\r\n                    // code assumes at least one argument\r\n                    while (true) {\r\n                        args.push(parse_expression(tokens));\r\n                        if (read_token(',', tokens)) continue;\r\n                        if (read_token(')', tokens)) break;\r\n                        throw \"Expected comma or close paren in function call\";\r\n                    }\r\n                    if (!(token in built_in_functions)) throw \"Call to unrecognized function: \" + token;\r\n                    return ['call ' + token].concat(args);\r\n                }\r\n                // otherwise its just a reference to a variable\r\n                return token;\r\n            }\r\n            // only option left: a number\r\n            var n = parseFloat(token, 10);\r\n            if (isNaN(n)) throw 'Expected a number, got ' + String(token);\r\n            return n;\r\n        }\r\n        else throw 'Unexpected end of expression';\r\n    }\r\n\r\n    function evaluate(tree, environment) {\r\n        if (environment === undefined) environment = built_in_environment;\r\n        if (typeof tree == 'number') return tree;\r\n        else if (typeof tree == 'string') return environment[tree]; // might be undefined\r\n        else {\r\n            // expecting [operator,tree,...]\r\n            var args = tree.slice(1).map(function(subtree) {\r\n                return evaluate(subtree, environment);\r\n            });\r\n            if (tree[0].search(/^call /) != -1) {\r\n                // call of built-in function\r\n                var f = tree[0].slice(5);\r\n                f = built_in_functions[f];\r\n                if (f === undefined) throw \"Unknown function: \" + f;\r\n                return f.apply(undefined, args);\r\n            }\r\n            // otherwise its just an operator\r\n            else switch (tree[0]) {\r\n            case 'neg':\r\n                return -args[0];\r\n            case '+':\r\n                return args[0] + args[1];\r\n            case '-':\r\n                return args[0] - args[1];\r\n            case '*':\r\n                return args[0] * args[1];\r\n            case '/':\r\n                return args[0] / args[1];\r\n            case '^':\r\n                return Math.pow(args[0],args[1]);   \r\n            default:\r\n                throw 'Unrecognized operator ' + tree[0];\r\n            }\r\n        }\r\n    }\r\n    exports.evaluate = evaluate;\r\n\r\n    function parse(text) {\r\n        // pattern matches integers, variable names, parens and the operators +, -, *, /\r\n        var pattern = /([0-9]*\\.)?[0-9]+([eE][\\-+]?[0-9]+)?|[a-zA-Z_]\\w*|\\+|\\-|\\*|\\/|\\^|\\(|\\)|\\,/g;\r\n        var tokens = text.match(pattern);\r\n        return parse_expression(tokens);\r\n    }\r\n    exports.parse = parse;\r\n\r\n    function calculate(text,environment) {\r\n        if (environment === undefined) environment = built_in_environment;\r\n        try {\r\n            var tree = parse(text);\r\n            return evaluate(tree, environment);\r\n        }\r\n        catch (err) {\r\n            return err;\r\n        }\r\n    }\r\n    exports.calculate = calculate;\r\n\r\n    function setup_calc(div) {\r\n        var input = $('<input></input>', {\r\n            type: 'text',\r\n            size: 50\r\n        });\r\n        var output = $('<div></div>');\r\n        var button = $('<button>Calculate</button>');\r\n        button.bind(\"click\", function() {\r\n            output.html(String(calculate(input.val())));\r\n        });\r\n\r\n        $(div).append(input, button, output);\r\n    }\r\n    exports.setup_calc = setup_calc;\r\n\r\n    return exports;\r\n\r\n}());"]],"start1":0,"start2":0,"length1":0,"length2":6971}]],"length":6971,"saved":false}
